#슬라이싱으로 문자열 나누기

"""a = "Life is too short, You need Python"
b = a[2:8:2]
print(b)"""  #a[이상:미만:간격] 간격에 -1하면 거꾸로 출력

#어떤 식으로 활용될 수 있나?

a = "20250723Rainy"
date = a[:8]
weather = a[8:]
print(f"{date} : It is {weather} today.")

#문자열 포매팅

name = "yongwook"
age = 24
a = f"My name is {name}, I'm {age + 1}."
print(a)

#소수점

y = 3.141592
a = f"{y:0.4f}" #소수점 4번째 자리까지 = 0.4f
print(a)

#문자열 개수 세기(count)
a = "hobby"
print(a.count('b'))

#위치 알려주기(find, index)
a = "Python is the best choice"
print(a.index('b'))

#문자열 삽입(join)
a = " to ".join('abcd')
print(a)

#소문자 대문자
a = "hi"
b = "HeLlo"
print(a.upper())
print(b.lower())

#공백 지우기
a = "    hi    "
print(a.lstrip())
print(a.rstrip())
print(a.strip())

#문자열 바꾸기(replace), 문자열 나누기(split)
a="Life is too short."
print(a.replace("Life", "He"))
print(a.split())    #문자열이 쪼개져서 list가 나온다. 기본적으로는 띄어쓰기를 기준으로 쪼갠다.

b="a:b:c:d"
print(b.split())
print(b.split(":")) #":"를 기준으로 쪼개라는 것.

#리스트

a= [1, 2, 3]
print(a[1]+a[2])
print(a[-1])

a = [1, "hello", 3, ['a', 'b', 'c']]
print(a[-1][1])
print(a[1][0])
print(a[:2])    #string 문자열(문자 + 리스트(배열))

#리스트 값 수정, 요소 삭제
a = [1, "hello", 3, ['a', 'b', 'c'], 5, 6]
a[1] = 2
del a[3:5]   #이렇게 슬라이싱도 가능하다.
print(a)


#리스트에 추가(append)

a = [1, 2, 3]
a.append([5, 6])  #이렇게 리스트 안에 리스트도 들어갈 수 있다.
print(a)

#그럼 리스트를 펼쳐서 추가하고 싶다면
#리스트 확장(extend)
a = [1, 2, 3]
a.extend([5, 6])
print(a)

#리스트 정렬(sort)
b = [1, 4, 5, 2, 3]
b.sort()
print(b)

#내림차순으로 정렬하고 싶다면
c = ['a', 'c', 'b']
c.sort()
c.reverse()
print(c)

#리스트에서의 find() 혹은 index()
a = [1, 2, 3]
print(a.index(3))

#리스트에 추가(insert)
a = [1, 2, 3]
a.insert(1,4) #insert(a,b) : a index에 b를 추가하겠다.
print(a)

#리스트 제거
a = [1, 2, 3, 1, 2, 3]
a.remove(3)   #첫 번째로 나오는 3을 제거한다.
print(a)
a.remove(3)
print(a)

#리스트 요소 끄집어 내기(pop)
a = [1, 2, 3]
a.pop() #맨 끝을 날려보내버린다. a.pop(1)이라 하면 1번 index를 날리는 것.
print(a.pop())  #어떤 게 튀어나가는지 볼 수 있다.
print(a)

#리스트에 포함된 요소 개수 세기(count)
a = [1, 2, 3, 1]
a.count(1)

x, y = map(int, input().split())
print(f"{(x+y)%z}")
print(f"{((x%z)+(y%z))%z}")
print(f"{(x*y)%z}")
print(f"{((x%z)*(y%z))%z}")


# Mutable vs Immutable
# 리스트,딕셔너리, 집합 vs 정수, 실수, 문자열, 튜플

# tuple
t1 = 1, 2, 3
print(type(t1))

t1 = (1, 2, "a", "b")
print(t1[0])
#슬라이싱하기
print(t1[1::2])
print(t1)
t2 = (3, 4)
t3 = t1 + t2
print(t3)
print(t1*3)

#dictionary
#dic = {"key" : "value", "key" : "value", ...}

dic = {
    "name" : "yongwook",
    "age" : 24,
    "hobby" : ["basketball", "piano"]
}
#추가
dic["girlfriend"] = "GH"
#수정
dic["name"] = "yongwook lee"
#삭제
del dic["hobby"]
print(dic)

#key를 사용해서 value를 얻기

grade = {'YW' : "100", 'GH' : "101"}
print(grade["YW"])

print("ㅡ"*10)
#.keys()
print(grade.keys())
for k in grade.keys():
  print(k)

#.values()
print(grade.values())

#.items() -> list 안에 tuple이 들어간 형태로 print된다
print(grade.items())

#.clear()
grade.clear()
print(grade)

#.get()

a = {'name' : 'YongWook', 'phone' : '010-0000-2222', 'birth':'010112'}
print(a.get('phone',"not found"))
print(a.get('hobby',"not found"))

#in
print('name'in a)
print('hobby'in a)

#집합
s1 = set([1,2,3])
s2 = {4,5,5,6}
print(type(s1))
print(s2)

s1 = set("Hello")
print(s1)
#집합에는 순서가 없다. 따라서 인덱스로 접근하는 게 말이 안된다. indexing 하고 싶으면 list로 감싸든지.
#중복되는 원소는 제거된다.

s1 = set([1,2,3,4,5,6])
s2 = set([4,5,6,7,8,9])
print(s1 | s2)
print(s1.union(s2))

print(s1 & s2)
print(s1.intersection(s2))

print(s1 - s2)
print(s2.difference(s1))

#집합에 추가

s1 = set([1,2,3])
#1개씩 추가
s1.add(4)
print(s1)
#여러개를 추가
s1.update([5,6,7])
print(s1)

#bool - true / false
a = 1 == 2
print(a)

#자료형의 참과 거짓(속성)

#값이 비어있으면 거짓이다.

a = [1,2,3,4]
while a:
  print(a)
  a.pop()

#<변수>
#-자료형의 값을 저장하는 공간

a = [1,2,3]
#print(id(a))
#>>140643391523264

b = a
#b라는 변수에 a의 주소를 할당한다.

a[1]=4
#print(a,b)
#>>[1, 4, 3] [1, 4, 3]

#왜 b도 바뀌나? b는 a의 주소를 담은 변수이기 때문에.
#b 변수를 생성할 때 a 변수의 값을 가져오면서 a와는 다른 주소를 가리키도록 만들 수 있을까?

b = a[:]
#a의 리스트를 슬라이싱 해서 값만 가져옴. a의 값을 복사해서 새로운 메모리에 넣은 것


#변수에 한번에 값을 할당
a, b = "apple", "banana"
print(a)
print(b)
#튜플로 감싼다. a, b = ("apple", "banana")
# (a, b) = "apple", "banana"
# 다 같은것.

#a=3, b=5에서 두 변수의 값을 바꾸고 싶다면
a=3
b=5
a,b = b,a
print(a)
print(b)
